- 
- [[@U4IQDNUW]]
- ![](http://3.bp.blogspot.com/-94wKvhZfIBg/TzFQpiboMsI/AAAAAAAAACw/5tR2IeI4wGo/s640/OAuth2-2.0_Diagrams+token+grant.jpg)
- > In the Facebook Connect case:
- > 1. The Website (client in OAuth speak) redirects the user to Facebook asking for access to the users portion of the Facebook Graph API endpoint.
- > 2. Facebook gets the users Authorization to give that access. 
- > 3. Facebook then redirects the user back to the client passing an access token in the URL fragment. 
- > 4. The client performs a GET on the Facebook API endpoint using the access token from step 
- > 5. The Graph API endpoint returns a JSON object that contains a Facebook user_id and other public and perhaps private information based on what access the user granted. 
- > 6. The Website logs in user in as the user_id from the Graph API endpoint.
- >The advantage to this is that anyone can read the instructions on the [Facebook Developers Page](http://developers.facebook.com/docs/authentication/) and make their website a client.
- > The disadvantage is that they have no security.  Not to put too fine a point on it, **they have not Authenticated the User.**  They have gotten delegated access to the users information.
- 
- > The hard reality is that people go to questionable websites.  One of the things people do at those sites is use Facebook, openID or Twitter to login.  This avoids sharing their email and password with the site.
- > So we wind up in the situation where any site the user loges into with their Facebook account can impersonate that user at any other site that accepts Facebook logins through the [Client-side Flow](https://developers.facebook.com/docs/authentication/#client-side-flow)(the default for Facebook).  The less common [Server-side Flow](https://developers.facebook.com/docs/authentication/#server-side-flow) is more secure, but more complicated.
- 
- client 無法知道該token 會是頒發給誰的? 
- >  Only the access_token parameter is generated by the Authorization server, all the other parameters are dropped or echoed back.   The client has no way to tell who the authorization server thought it was issuing that access_token to.
- 解法的主旨為: 讓即將頒發的token 增加受眾資訊，換言之，哪個受眾(audience)可以使用該token
- > In OAuth the token is intended for the consumption of the protected resource, and intentionally opaque to the client (RP).  The RP has no way to tell from the token if it was generated for it or another RP.
- > You could say the audience for the OAuth token is the protected resource and the audience for a authentication token is the RP.   They are not the same endpoint!
- 
- 重點:
- OAuth 2.0 常見流程大都專注於如何授予使用者權限至client，並讓client持著代表權限的token去索要資源，但卻留下幾個問題:
    - token 的使用者(client)是否為合法對象(client)?
    - 使用token的對象是否會濫用該token來索要資源
- 造就其問題的原因為:
    - 授予權限的過程沒對使用token的使用者進行 "使用者是否為合法使用者" 的相關認證
- 解法概念為
    -  讓即將頒發的token 增加受眾資訊，換言之，哪個受眾(audience)可以使用該token
    - 在OpenID Connect 中是將 "誰可以使用該token" 受眾資訊添加至與token，該token 被命名為id token，命名緣由為: 該token是以特定已受過認證的使用者資訊而構成，並且綁定特定id來標明誰可以使用
- ---
- 
- ---
- tags: [[Authorization]] [[OpenID]] [[OAuth]]
- links: [[id token 本身是用來證明特定使用者是受過認證的資訊，使用者或者Relying Party 向OpenID Provider提供特定身份的證明資訊，接著由OpenID Provider對其進行驗證，若驗證成功就會發放對應token]]
