- 
- [[@U4IQDNUW]]
- ![](http://3.bp.blogspot.com/-94wKvhZfIBg/TzFQpiboMsI/AAAAAAAAACw/5tR2IeI4wGo/s640/OAuth2-2.0_Diagrams+token+grant.jpg)
- > In the Facebook Connect case:
- > 1. The Website (client in OAuth speak) redirects the user to Facebook asking for access to the users portion of the Facebook Graph API endpoint.
- > 2. Facebook gets the users Authorization to give that access. 
- > 3. Facebook then redirects the user back to the client passing an access token in the URL fragment. 
- > 4. The client performs a GET on the Facebook API endpoint using the access token from step 
- > 5. The Graph API endpoint returns a JSON object that contains a Facebook user_id and other public and perhaps private information based on what access the user granted. 
- > 6. The Website logs in user in as the user_id from the Graph API endpoint.
- >The advantage to this is that anyone can read the instructions on the [Facebook Developers Page](http://developers.facebook.com/docs/authentication/) and make their website a client.
- > The disadvantage is that they have no security.  Not to put too fine a point on it, **they have not Authenticated the User.**  They have gotten delegated access to the users information.
- 
- > The hard reality is that people go to questionable websites.  One of the things people do at those sites is use Facebook, openID or Twitter to login.  This avoids sharing their email and password with the site.
- > So we wind up in the situation where any site the user loges into with their Facebook account can impersonate that user at any other site that accepts Facebook logins through the [Client-side Flow](https://developers.facebook.com/docs/authentication/#client-side-flow)(the default for Facebook).  The less common [Server-side Flow](https://developers.facebook.com/docs/authentication/#server-side-flow) is more secure, but more complicated.
- 
- client 無法知道該token 會是頒發給誰的? 
- >  Only the access_token parameter is generated by the Authorization server, all the other parameters are dropped or echoed back.   The client has no way to tell who the authorization server thought it was issuing that access_token to.
- 解法的主旨為: 讓即將頒發的token 增加受眾資訊，換言之，哪個受眾(audience)可以使用該token
- > In OAuth the token is intended for the consumption of the protected resource, and intentionally opaque to the client (RP).  The RP has no way to tell from the token if it was generated for it or another RP.
- > You could say the audience for the OAuth token is the protected resource and the audience for a authentication token is the RP.   They are not the same endpoint!
- 
- 重點:
- OAuth 2.0 常見流程大都專注於如何授予使用者權限至client，並讓client持著代表權限的token去索要資源，但卻留下幾個問題:
    - token 的使用者(client)是否為合法對象(client)?
    - ~~使用token的對象是否會濫用該token來索要資源~~
- 造就其問題的原因為:
    - 驗證token之過程沒對使用token的使用者進行 "使用者是否為合法使用者" 的相關認證
- 解法概念為
    -  讓即將頒發的token 添加哪個使用者可以合法使用該token，並於驗證時去比對當時使用token的使用者和token的合法使用者之資訊是否一樣，若一樣就允許使用，若不一樣就不允許使用
    - 在OpenID Connect 中的id token是添加哪audience claim 並填寫頒發token的最後接收者之id-客戶端的client id，每一次驗證token都會要求客戶端提供自身的client id來比對id token內的audience claim是否一樣。
- 
- 
- ---
- #Test OAuth 本身存在甚麼樣的問題
    - 1. token 的使用者(client)是否為合法對象(client)?
- #Test OAuth 存在著 "token 的使用者(client)是否為合法對象(client)" 這個問題，那麼其造成的原因為何?
    - 驗證token之過程沒對使用token的使用者進行 "使用者是否為合法使用者" 的相關認證
- #Test OAuth 存在著 "token 的使用者(client)是否為合法對象(client)" 這個問題，那麼解法概念為何?
    - 讓即將頒發的token 添加哪個使用者可以合法使用該token，並於驗證時去比對當時使用token的使用者和token的合法使用者之資訊是否一樣，若一樣就允許使用，若不一樣就不允許使用
- #Test 在OpenID Connect 中，id token 針對"token 的使用者(client)是否為合法對象(client)" 這個問題，其實際做法是甚麼? 
    -  在OpenID Connect 中的id token是添加哪audience claim 並填寫頒發token的最後接收者之id-客戶端的client id，每一次驗證token都會要求客戶端提供自身的client id來比對id token內的audience claim是否一樣。
- ---
- tags: [[Authorization]] [[OpenID]] [[OAuth]]
- links: [[id token 本身是用來證明特定使用者是受過認證的資訊，使用者或者Relying Party 向OpenID Provider提供特定身份的證明資訊，接著由OpenID Provider對其進行驗證，若驗證成功就會發放對應token]]
